# php-interview

# OPCACHE

Улучшает производительность PHP путём сохранения скомпилированного байт-кода скриптов в разделяемой памяти, тем самым избавляя PHP от необходимости загружать и анализировать скрипты при каждом запросе.

# namespace
Использование namespace в PHP помогает управлять и структурировать код, предотвращать конфликты имен, улучшать читаемость и масштабируемость проектов, а также упрощает интеграцию с внешними библиотеками и стандартами автозагрузки.

# OOP
Наследование – это свойство позволяющее описать новый класс на основе уже существующего функциональностью

Полиморфизм - изменение решение проблемы разными способами в child классах

Инкапсуляция – позволяет объединить данные и методы, работающие с ними, в классе и скрыть детали
реализации от пользователей

# Singleton
Паттерн Singleton полезен, когда нужно, чтобы приложение использовало один и тот же экземпляр класса в разных частях программы. Однако его следует использовать с осторожностью, так как он может привести к трудностям с тестированием, расширением и пониманием кода в больших проектах.
В Laravel Singleton — это мощный инструмент для управления уникальными экземплярами объектов. Он используется для реализации таких компонентов, как:

Логгеры.
Подключения к базе данных.
Кэш и другие сервисы, требующие единого экземпляра.

# Dependency Injection (DI) и Dependency Inversion Principle (DIP)
Dependency Inversion Principle (DIP - Принцип Инверсии Зависимостей) — это принцип, который требует, чтобы модули высокого уровня зависели от абстракций, а не от конкретных реализаций. Этот принцип уменьшает связанность кода и делает его более гибким.
Dependency Injection (DI - Внедрение Зависимостей) — это способ реализации принципа DIP, при котором зависимости передаются в объект извне, а не создаются им самим.

# Traits
Они позволяют вам выделить общую функциональность и применить её к нескольким классам, без создания жесткой зависимости, как это происходит при наследовании.

Преимущества Traits:
- Переиспользование кода: Traits позволяют выделять общие части кода и использовать их в разных классах.
- Гибкость: Traits могут быть использованы в любом классе без необходимости изменять иерархию наследования.
- Избежание дублирования кода: Механизм позволяет избежать дублирования кода, что упрощает поддержку.


# Абстрактный класс и интерфейс

Абстрактный класс и интерфейс - это два ключевых концепта объектно-ориентированного программирования, используемых для реализации полиморфизма. Вот основные различия между ними:

Реализация методов:

Абстрактный класс: Может содержать как абстрактные методы (методы без тела), так и конкретные методы (методы с телом).
Интерфейс: Может содержать только абстрактные методы, которые не имеют реализации.

Наследование:
Абстрактный класс: От него можно наследовать только один класс, так как поддерживается одиночное наследование.
Интерфейс: Может быть реализовано несколькими классами, так как поддерживается множественное наследование.

Поля класса:
Абстрактный класс: Может содержать поля, которые могут быть как абстрактными, так и конкретными.
Интерфейс: Не может содержать переменных, кроме констант.

Пример использования:
Абстрактный класс: Используется, когда необходимо предоставить базовую реализацию для группы связанных классов.
Интерфейс: Используется, когда требуется, чтобы несколько различных классов обеспечивали одинаковый набор методов, но с различной реализацией.

В целом, выбор между абстрактным классом и интерфейсом зависит от конкретной ситуации и требований вашего проекта.

# SOLID

Вот как расшифровывается акроним SOLID:

S: Single Responsibility Principle (Принцип единственной ответственности).
User, Email

O: Open-Closed Principle (Принцип открытости-закрытости).
поведение класса должно быть изменяемым без изменения самого класса.

L: Liskov Substitution Principle (Принцип подстановки Барбары Лисков).

класс B является подклассом класса A, то объекты класса A могут быть заменены объектами класса B без изменения правильности программы. Проще говоря, подкласс должен дополнять, а не нарушать поведение базового класса

I: Interface Segregation Principle (Принцип разделения интерфейса).
Интерфейсы должны быть разделены на более мелкие, специфичные интерфейсы, предназначенные для конкретных клиентов.

D: Dependency Inversion Principle (Принцип инверсии зависимостей).
классы должны зависеть от абстракций, а не от конкретных реализаций

1. Высокоуровневые модули не должны зависеть от низкоуровневых модулей. Оба типа модулей должны зависеть от абстракций.
2. Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций.

# KISS 
это принцип проектирования и программирования, при котором простота системы декларируется в качестве основной цели или ценности. Есть два варианта расшифровки аббревиатуры: «keep it simple, stupid» и более корректный «keep it short and simple»

KISS – keep it short simple – делайте вещи проще. Порой наиболее правильное решение – это наиболее простая реализация задачи, в которой нет ничего лишнего.

# DRY
Don't repeat yourself (DRY; с англ. — «не повторяйся») — это принцип разработки программного обеспечения, нацеленный на снижение повторения информации различного рода, особенно в системах со множеством слоёв абстрагирования.

DRY – Don’t repeat yourself – принцип призывает Вас не повторяться при написании кода. Все что Вы пишите в проекте, должно быть определено только один раз.


# Индексы
Существуют следующие типы индексов:

Уникальный (Unique index) — все значения встречаются только один раз. Если в столбец с уникальным индексом попробовать добавить неуникальное значение, то возникнет
ошибка.

Неуникальный (Non-unique index) — индекс, при котором значения могут повторяться.

Простой (Simple index) — индекс, состоящий из одного поля.

Составной (Composite Index) — индекс, который строится по нескольким столбцам таблицы. В данном типе индекса расположение полей является важным.

Древовидный (B-tree index) — индекс, который представлен в виде корневой вершины и узлов.

Частичный (Partial Indexes) — индекс, который состоит из подмножеств строк таблицы по определенному выражению.

# Модификатора доступа

1. public
   Описание: Члены класса, объявленные как public, доступны отовсюду. Вы можете обращаться к ним из любого места программы, включая объекты этого класса, наследники и код за пределами класса.
2. protected
   Описание: Члены класса, объявленные как protected, доступны только внутри самого класса и его подклассов (наследников). Они недоступны из кода, находящегося за пределами этих классов.
3. private
   Описание: Члены класса, объявленные как private, доступны только внутри самого класса. Они недоступны ни для наследников, ни для любого другого кода вне этого класса.

Сводная таблица:
Модификатор	Доступ внутри класса	Доступ в наследниках	Доступ извне

![img.png](img.png)

Использование модификаторов доступа
Модификаторы доступа позволяют скрывать внутренние детали реализации класса и предоставлять только те методы и свойства, которые необходимы для использования класса извне. Это улучшает инкапсуляцию, делает код более защищенным и легко модифицируемым.

# замыкания (closures)

PHP замыкания (closures) представляют собой анонимные функции, которые могут захватывать переменные из внешней области видимости. Это позволяет функции "помнить" состояние окружения, в котором она была создана.

__construct() — вызывается при создании объекта (конструктор).
__destruct() — вызывается при уничтожении объекта (деструктор).
__get($name) — вызывается при доступе к неопределённому или недоступному свойству.
__set($name, $value) — вызывается при присвоении значения неопределённому или недоступному свойству.
__isset($name) — вызывается при использовании isset() или empty() на неопределённом или недоступном свойстве.
__unset($name) — вызывается при использовании unset() на неопределённом или недоступном свойстве.
__call($name, $arguments) — вызывается при вызове неопределённого или недоступного метода.
__callStatic($name, $arguments) — вызывается при вызове неопределённого или недоступного статического метода.
__toString() — вызывается при попытке представить объект в виде строки.
__invoke() — вызывается при попытке использовать объект как функцию.
__clone() — вызывается при клонировании объекта.
__sleep() — вызывается перед сериализацией объекта.
__wakeup() — вызывается при десериализации объекта.
__debugInfo() — определяет, какие данные будут отображаться при использовании var_dump().

# PSR

PSR (PHP Standards Recommendations) — это набор стандартов, разработанных сообществом PHP-FIG (Framework Interop Group) для обеспечения согласованности и совместимости PHP-кода между различными проектами и фреймворками.

Почему важно следовать PSR?

Согласованность кода: Разные разработчики или команды пишут в одном стиле.
Совместимость: Легче интегрировать библиотеки и фреймворки.
Читаемость: Код, соответствующий PSR, проще понять и поддерживать.

PSR (PHP Standards Recommendations) — это набор стандартов, разработанных PHP-FIG (Framework Interoperability Group) для обеспечения согласованности кода между различными PHP-проектами. Ниже приведены основные PSR и их ключевые принципы:

1. PSR-1: Базовый стандарт кодирования
   Файлы должны быть в UTF-8 без BOM.
   Пространства имен (namespace) и классы должны соответствовать PSR-4 (автозагрузка).
   Имена классов должны использовать StudlyCaps (MyClassName).
   Константы должны быть в SNAKE_CASE (MY_CONSTANT).
   Методы и переменные должны быть в camelCase (myMethodName).
   Функции и методы должны использовать declare(strict_types=1); (рекомендуется).
2. PSR-2: Стиль кодирования (заменен на PSR-12)
   Отступы — 4 пробела (не табуляция).
   Максимальная длина строки — 80-120 символов.
   Открывающая { должна быть на новой строке для классов и методов.
   Использовать один класс на файл.
   Нет закрывающего ?> в файлах PHP.
3. PSR-3: Логирование
   Определяет интерфейс логирования LoggerInterface.
   Поддержка уровней логирования (например, DEBUG, INFO, WARNING, ERROR).
   Позволяет внедрять разные реализации логирования, например, Monolog.
4. PSR-4: Автозагрузка
   Определяет стандартизированную автозагрузку классов.
   Каждый класс должен находиться в отдельном файле.
   Пространства имен соответствуют структуре каталогов (App\Controllers\HomeController → src/App/Controllers/HomeController.php).
   Полное отсутствие require и include — только composer autoload.
5. PSR-6 и PSR-16: Кэширование
   PSR-6: Определяет интерфейс кэширования (CacheItemPoolInterface).
   PSR-16: Упрощенный API кэша (CacheInterface с методами get(), set(), delete()).
6. PSR-7: HTTP-сообщения
   Описывает объектное представление HTTP-запросов и ответов.
   Включает RequestInterface, ResponseInterface, StreamInterface и другие.
   Используется в Laravel, Symfony, Slim, Guzzle.
7. PSR-11: Контейнер зависимостей
   Определяет единый интерфейс для контейнеров зависимостей (ContainerInterface).
   Позволяет легко менять реализацию DI-контейнера (например, Pimple, PHP-DI).
8. PSR-12: Расширенный стандарт кодирования (замена PSR-2)
   Больше требований к форматированию:
   Операторы use должны быть каждый на новой строке.
   Логические операторы (&&, ||) должны быть в начале строки, а не в конце.
   Не допускаются многосимвольные псевдонимы (<?php вместо <?).

# Анонимные функции
Анонимные функции в PHP — это функции без имени, которые можно присваивать переменным, передавать в другие функции как аргументы или использовать в местах, где требуется динамическая логика.

# нормализация
  Что такое нормализация базы данных?
  Нормализация — это процесс организации данных в базе данных для уменьшения избыточности и улучшения целостности данных. Этот процесс включает разбиение данных на несколько таблиц и установление между ними связей, с целью минимизации дублирования данных и предотвращения аномалий при добавлении, удалении или обновлении данных.

  Нормализация базы данных — это процесс улучшения структуры таблиц, минимизация избыточности и обеспечение целостности данных. Это делается с помощью последовательного применения нормальных форм (1NF, 2NF, 3NF и так далее).

# ACID 
Принципы ACID необходимы для обеспечения надежности и корректности работы транзакций в реляционных базах данных. Эти свойства позволяют гарантировать, что данные всегда остаются в согласованном состоянии, даже при сбоях системы, и что транзакции выполняются корректно, независимо от их сложности или ситуации в системе.

ACID — это набор принципов, который описывает, как должны работать транзакции в реляционных базах данных, чтобы гарантировать, что они будут выполняться надежно, даже при сбоях системы. ACID является акронимом, который расшифровывается как:
перед и после выполнения транзакции база данных должна удовлетворять всем ее правилам
A — Atomicity (Атомарность - Атомарность гарантирует, что транзакция либо выполняется полностью, либо не выполняется вообще.)
C — Consistency (Согласованность - перед и после выполнения транзакции база данных должна удовлетворять всем ее правилам)
I — Isolation (Изоляция - Изоляция определяет, насколько результаты транзакций могут быть видны другим транзакциям, пока текущая транзакция не завершена.)
D — Durability (Долговечность - Долговечность гарантирует, что после того как транзакция была зафиксирована, ее изменения сохраняются в базе данных, даже если происходит сбой системы (например, падение сервера или сбой питания)

# PHP
# PHP 7.4 (выпущена 28 ноября 2019 года):

Стрелочные функции (arrow functions): позволяют писать более краткий синтаксис для анонимных функций.
Typed Properties: возможность объявлять типы свойств в классах.
Опциональные значения для spread оператора в массивах: упрощает работу с массивами.
Улучшения производительности: дополнительные оптимизации для повышения скорости выполнения кода.

# PHP 8.0 (выпущена 26 ноября 2020 года):

JIT-компиляция (Just-In-Time): значительное улучшение производительности за счет компиляции кода во время выполнения.
Union Types: возможность указания нескольких типов для переменных, аргументов и возвращаемых значений функций.
Нулевой безопасный оператор (??=): позволяет присваивать значение переменной, если она еще не установлена.
Именованные аргументы: позволяют передавать значения аргументов функций по имени, улучшая читаемость кода.
Новые атрибуты: введение атрибутов для метаданных классов и функций.
# PHP 8.1 (выпущена 25 ноября 2021 года):

Enumerations (Enums): введение перечислений для определения набора возможных значений переменной.
Readonly Properties: свойства, которые можно установить только один раз и не изменять впоследствии.
Fibers: механизм для управления потоками выполнения, упрощая работу с асинхронным кодом.
Intersection Types: возможность указания типов, которые должны соответствовать всем указанным интерфейсам.
# PHP 8.2 (выпущена 8 декабря 2022 года):

Readonly Classes: классы, все свойства которых являются только для чтения.
Декларация типов null, false и true: возможность использования этих типов в объявлениях.
Дизъюнктивная нормальная форма типов: позволяет комбинировать типы с использованием логических операторов.
Устаревание и удаление некоторых функций: например, интерполяция строк вида ${} была объявлена устаревшей.

# магические методы
1. __construct
2. __destruct,
3. __get,
4. __set, 
5. __call,
6. __callStatic, 
7. __toString, 
8. __invoke,
9. __isset, 
10. __unset,
11. __clone

# Дополнить -----------------------------

- Что такое middleware Laravel?
- Укажите разницу между методом get и post.
- Что такое контракты laravel?
- Что такое Composer? 
- Модификатора доступа

- Что означает ORM? 
- Доступные типы отношений в Laravel Eloquent. 
- Что такое пространство имен в Laravel? 
- Какие знаете принципы ООП? 
- разница между обстрактным класом и интерфейсом
- Что такое traits? 
- Что такое нормализация?
- В чем разница между первичным и уникальным ключами? 
- Разница между LEFT JOIN, RIGHT JOIN, INNER JOIN 
- Что такое полиморфные связи, как они работают? 
- Что такое Mock? Где используют и зачем? 
- Монолит микросервис 
- DRY/KISS
- SOLID
- docker 
- rabitmq/kafka
- redis
- Feathure/Unit test 
- Оптимизация запросов, устранение лишних запросов 
- Транзакций
- mysql explain
- acid

- ООП
- SOLID
- PHP
- Redis (как кэш и очередь) (почему нельзя хранить данные деген сурагы бар, потому что после рестарта данные пропадают деп айтасын. Но если настроить хранилище то можно сделать так чтобы не удалялись после рестарта)
- Laravel Другие фреймворки и их разница
- Индексы, Составные индексы
- Абстракция интерфейс

- RabbitMQ/Kafka
- ElasticSearch
- Git

- Структура данных
- разница php fpm от php cli
- yeld return
- деп инжекшн vs деп инвершн
- singleton
- макросы
- разница между очередью и джобы в laravel
- магические методы (__construct, __destruct, __get, __set, __call, __callStatic, __toString, __invoke, __isset, __unset, __clone)
- замыкания
- генераторы

- паттерн репозиторий
- паттерн обсервер
- зачем дто а не класс
- where and having difference
- git flow
- предметно ориентированное проектирование

- паттерн репозиторий
- паттерн обсервер 
- зачем дто а не класс 
- where and having difference 
- git flow 
- предметно ориентированное проектирование 
- парадигмы программирования 
- ооп принципы 
- options, head rest api 
- joins sql 
- redis типы данных 
- маршрутизация rabbitmq 
- сервис провайдер это 
- фасад ларавел