# php-interview

# OPCACHE

Улучшает производительность PHP путём сохранения скомпилированного байт-кода скриптов в разделяемой памяти, тем самым избавляя PHP от необходимости загружать и анализировать скрипты при каждом запросе.

# namespace
Использование namespace в PHP помогает управлять и структурировать код, предотвращать конфликты имен, улучшать читаемость и масштабируемость проектов, а также упрощает интеграцию с внешними библиотеками и стандартами автозагрузки.

# OOP
Наследование – это свойство позволяющее описать новый класс на основе уже существующего функциональностью

Полиморфизм - изменение решение проблемы разными способами в child классах

Инкапсуляция – позволяет объединить данные и методы, работающие с ними, в классе и скрыть детали
реализации от пользователей

# Singleton
Паттерн Singleton полезен, когда нужно, чтобы приложение использовало один и тот же экземпляр класса в разных частях программы. Однако его следует использовать с осторожностью, так как он может привести к трудностям с тестированием, расширением и пониманием кода в больших проектах.
В Laravel Singleton — это мощный инструмент для управления уникальными экземплярами объектов. Он используется для реализации таких компонентов, как:

Логгеры.
Подключения к базе данных.
Кэш и другие сервисы, требующие единого экземпляра.

# Dependency Injection (DI) и Dependency Inversion Principle (DIP)
Dependency Inversion Principle (DIP - Принцип Инверсии Зависимостей) — это принцип, который требует, чтобы модули высокого уровня зависели от абстракций, а не от конкретных реализаций. Этот принцип уменьшает связанность кода и делает его более гибким.
Dependency Injection (DI - Внедрение Зависимостей) — это способ реализации принципа DIP, при котором зависимости передаются в объект извне, а не создаются им самим.

# Traits
Они позволяют вам выделить общую функциональность и применить её к нескольким классам, без создания жесткой зависимости, как это происходит при наследовании.

Преимущества Traits:
- Переиспользование кода: Traits позволяют выделять общие части кода и использовать их в разных классах.
- Гибкость: Traits могут быть использованы в любом классе без необходимости изменять иерархию наследования.
- Избежание дублирования кода: Механизм позволяет избежать дублирования кода, что упрощает поддержку.


# Абстрактный класс и интерфейс

Абстрактный класс и интерфейс - это два ключевых концепта объектно-ориентированного программирования, используемых для реализации полиморфизма. Вот основные различия между ними:

Реализация методов:

Абстрактный класс: Может содержать как абстрактные методы (методы без тела), так и конкретные методы (методы с телом).
Интерфейс: Может содержать только абстрактные методы, которые не имеют реализации.

Наследование:
Абстрактный класс: От него можно наследовать только один класс, так как поддерживается одиночное наследование.
Интерфейс: Может быть реализовано несколькими классами, так как поддерживается множественное наследование.

Поля класса:
Абстрактный класс: Может содержать поля, которые могут быть как абстрактными, так и конкретными.
Интерфейс: Не может содержать переменных, кроме констант.

Пример использования:
Абстрактный класс: Используется, когда необходимо предоставить базовую реализацию для группы связанных классов.
Интерфейс: Используется, когда требуется, чтобы несколько различных классов обеспечивали одинаковый набор методов, но с различной реализацией.

В целом, выбор между абстрактным классом и интерфейсом зависит от конкретной ситуации и требований вашего проекта.

# SOLID

Вот как расшифровывается акроним SOLID:

S: Single Responsibility Principle (Принцип единственной ответственности).
User, Email

O: Open-Closed Principle (Принцип открытости-закрытости).
поведение класса должно быть изменяемым без изменения самого класса.

L: Liskov Substitution Principle (Принцип подстановки Барбары Лисков).

класс B является подклассом класса A, то объекты класса A могут быть заменены объектами класса B без изменения правильности программы. Проще говоря, подкласс должен дополнять, а не нарушать поведение базового класса

I: Interface Segregation Principle (Принцип разделения интерфейса).
Интерфейсы должны быть разделены на более мелкие, специфичные интерфейсы, предназначенные для конкретных клиентов.

D: Dependency Inversion Principle (Принцип инверсии зависимостей).
классы должны зависеть от абстракций, а не от конкретных реализаций

1. Высокоуровневые модули не должны зависеть от низкоуровневых модулей. Оба типа модулей должны зависеть от абстракций.
2. Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций.

# KISS 
это принцип проектирования и программирования, при котором простота системы декларируется в качестве основной цели или ценности. Есть два варианта расшифровки аббревиатуры: «keep it simple, stupid» и более корректный «keep it short and simple»

KISS – keep it short simple – делайте вещи проще. Порой наиболее правильное решение – это наиболее простая реализация задачи, в которой нет ничего лишнего.

# DRY
Don't repeat yourself (DRY; с англ. — «не повторяйся») — это принцип разработки программного обеспечения, нацеленный на снижение повторения информации различного рода, особенно в системах со множеством слоёв абстрагирования.

DRY – Don’t repeat yourself – принцип призывает Вас не повторяться при написании кода. Все что Вы пишите в проекте, должно быть определено только один раз.


# Индексы
Существуют следующие типы индексов:

Уникальный (Unique index) — все значения встречаются только один раз. Если в столбец с уникальным индексом попробовать добавить неуникальное значение, то возникнет
ошибка.

Неуникальный (Non-unique index) — индекс, при котором значения могут повторяться.

Простой (Simple index) — индекс, состоящий из одного поля.

Составной (Composite Index) — индекс, который строится по нескольким столбцам таблицы. В данном типе индекса расположение полей является важным.

Древовидный (B-tree index) — индекс, который представлен в виде корневой вершины и узлов.

Частичный (Partial Indexes) — индекс, который состоит из подмножеств строк таблицы по определенному выражению.

# Модификатора доступа

1. public
   Описание: Члены класса, объявленные как public, доступны отовсюду. Вы можете обращаться к ним из любого места программы, включая объекты этого класса, наследники и код за пределами класса.
2. protected
   Описание: Члены класса, объявленные как protected, доступны только внутри самого класса и его подклассов (наследников). Они недоступны из кода, находящегося за пределами этих классов.
3. private
   Описание: Члены класса, объявленные как private, доступны только внутри самого класса. Они недоступны ни для наследников, ни для любого другого кода вне этого класса.

Сводная таблица:
Модификатор	Доступ внутри класса	Доступ в наследниках	Доступ извне

![img.png](img.png)

Использование модификаторов доступа
Модификаторы доступа позволяют скрывать внутренние детали реализации класса и предоставлять только те методы и свойства, которые необходимы для использования класса извне. Это улучшает инкапсуляцию, делает код более защищенным и легко модифицируемым.

# замыкания (closures)

PHP замыкания (closures) представляют собой анонимные функции, которые могут захватывать переменные из внешней области видимости. Это позволяет функции "помнить" состояние окружения, в котором она была создана.

__construct() — вызывается при создании объекта (конструктор).
__destruct() — вызывается при уничтожении объекта (деструктор).
__get($name) — вызывается при доступе к неопределённому или недоступному свойству.
__set($name, $value) — вызывается при присвоении значения неопределённому или недоступному свойству.
__isset($name) — вызывается при использовании isset() или empty() на неопределённом или недоступном свойстве.
__unset($name) — вызывается при использовании unset() на неопределённом или недоступном свойстве.
__call($name, $arguments) — вызывается при вызове неопределённого или недоступного метода.
__callStatic($name, $arguments) — вызывается при вызове неопределённого или недоступного статического метода.
__toString() — вызывается при попытке представить объект в виде строки.
__invoke() — вызывается при попытке использовать объект как функцию.
__clone() — вызывается при клонировании объекта.
__sleep() — вызывается перед сериализацией объекта.
__wakeup() — вызывается при десериализации объекта.
__debugInfo() — определяет, какие данные будут отображаться при использовании var_dump().

# PSR

PSR (PHP Standards Recommendations) — это набор стандартов, разработанных сообществом PHP-FIG (Framework Interop Group) для обеспечения согласованности и совместимости PHP-кода между различными проектами и фреймворками.

Почему важно следовать PSR?

Согласованность кода: Разные разработчики или команды пишут в одном стиле.
Совместимость: Легче интегрировать библиотеки и фреймворки.
Читаемость: Код, соответствующий PSR, проще понять и поддерживать.

# Анонимные функции
Анонимные функции в PHP — это функции без имени, которые можно присваивать переменным, передавать в другие функции как аргументы или использовать в местах, где требуется динамическая логика.

# магические методы
1. __construct
2. __destruct,
3. __get,
4. __set, 
5. __call,
6. __callStatic, 
7. __toString, 
8. __invoke,
9. __isset, 
10. __unset,
11. __clone

# Дополнить -----------------------------

- Что такое middleware Laravel?
- Укажите разницу между методом get и post.
- Что такое контракты laravel?
- Что такое Composer? 
- Модификатора доступа

- Что означает ORM? 
- Доступные типы отношений в Laravel Eloquent. 
- Что такое пространство имен в Laravel? 
- Какие знаете принципы ООП? 
- разница между обстрактным класом и интерфейсом
- Что такое traits? 
- Что такое нормализация? 
- В чем разница между первичным и уникальным ключами? 
- Разница между LEFT JOIN, RIGHT JOIN, INNER JOIN 
- Что такое полиморфные связи, как они работают? 
- Что такое Mock? Где используют и зачем? 
- Монолит микросервис 
- DRY/KISS
- SOLID
- docker 
- rabitmq/kafka
- redis
- Feathure/Unit test 
- Оптимизация запросов, устранение лишних запросов 
- Транзакций
- mysql explain
- acid

- ООП
- SOLID
- PHP
- Redis (как кэш и очередь) (почему нельзя хранить данные деген сурагы бар, потому что после рестарта данные пропадают деп айтасын. Но если настроить хранилище то можно сделать так чтобы не удалялись после рестарта)
- Laravel Другие фреймворки и их разница
- Индексы, Составные индексы
- Абстракция интерфейс

- RabbitMQ/Kafka
- ElasticSearch
- Git

- Структура данных
- разница php fpm от php cli
- yeld return
- деп инжекшн vs деп инвершн
- singleton
- макросы
- разница между очередью и джобы в laravel
- магические методы (__construct, __destruct, __get, __set, __call, __callStatic, __toString, __invoke, __isset, __unset, __clone)
- замыкания
- генераторы